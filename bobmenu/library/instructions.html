<html>
<head>
<title>The Book-Scanning Project</title>
</head>
<body>

<h2>The Book-Scanning Project</h2>

Foolishly, I complained.
<p>

"I've got too many books," I said. "Not <em>too many</em>, of course. But
I have now reached the point where I can forget that I own a book."
<p>

"You should catalog your collection," someone said. "Keep the database
on your Palm."
<p>

"Hell no. It would take forever, and then it would keep taking forever
every time I bought more books. I don't need anything else to remember
regularly."
<p>

"You know," someone said, "I bet you could get a bar-code scanner cheap,
and scan the 
<a href="http://www.bowker.com/standards/home/isbn/">ISBN</a>
codes. Then it would be a Small Matter of Programming
to look up the titles on the Net."
<p>

My reply was offensive and heartfelt.
<p>

<h3>Research</h3>

The project requires several stages:

<ul>
<li>A bar-code scanner
<li>...which can be hooked up to a computer I own
<li>A program to convert the UPC bar-code number to an ISBN
<li>A web site or other Internet resource to look up books by ISBN
<li>A program to take a list of ISBNs, send them to that web site, and
store the results
<li>A program to convert the list of titles and authors to a format that
can be viewed on a Palm 3.
</ul>

In my usual logical, methodical way, I started in the middle.
<p>

<em>
<a href="#lookup">Looking up ISBNs</a>
-
<a href="#convert">Converting UPC to ISBN</a>
-
<a href="#scanner">Buying a scanner</a>
-
<a href="#query">Querying for Titles</a>
-
<a href="#afterword">Afterword</a>
</em>
<p>

Or, if you don't care about the historical details, here's
<em><a href="#quick">How To Make It Work For You</a></em>.
<p>

You probably want to check the
<a href="updates.html">Page of Updates to This Document</a>,
since some details have changed since I actually did this
myself.
<p>

And finally...
<em><a href="booklist.html">the Book List</a></em>.
<p>

<hr>

<h3><a name="lookup">Looking up ISBNs</a></h3>

A 
<a href="http://www.google.com/">Google</a>
search for 
<a href="http://www.google.com/search?q=isbn+search&btnG=Google+Search">"isbn search"</a>
turned up one big winner:
<a href="http://isbn.nu/">http://isbn.nu/</a>.
This site lets you enter an
<a href="http://www.bowker.com/standards/home/isbn/">ISBN</a>
-- or even a raw UPC number -- and then
looks up the book at several on-line booksellers, and gives you a price
comparison table.
<p>

Useful, but not what I was looking for. Since the site is just referring
queries to Amazon.com (and so on), I might as well go to those sites directly.
I don't need price comparisons. Possibly, if Amazon turns out to have an
incomplete ISBN database, I might want to come back to isbn.nu rather than
design queries for several booksellers myself. But Amazon probably has the
goods, right?
<p>

The
<a href="http://www.amazon.com/exec/obidos/subst/search/books-power.html">Amazon search form</a>
is large, ugly, and full of crap I don't need. I was resigned to figuring
out all its details when someone on rec.arts.sf.written pointed out that
a URL such as 
<a href="http://www.amazon.com/exec/obidos/ISBN=1565922867/">http://www.amazon.com/exec/obidos/ISBN=1565922867/</a>
would work as well. Bingo!
<p>

<h4>The snag:</h4>

At first, Amazon seemed to be finding less than ten percent of the
ISBNs I was submitting. Ack! Blah! Disaster! No, I was just generating
the ISBN checksum digit wrong, ten times out of eleven. 
(Naturally, the one book I had within reach was the eleventh case --
that's why I didn't catch the error.)
<p>

In fact, Amazon finds some 85% of my test run. By checking both Amazon.com
and Chapters.ca, I pushed that up to some 92%. Amazon.co.uk gave me a
few more. The remaining intractables
weren't found by any other web database I tried, so I expect that's the
best I'm going to get.
<p>

(Bowker provides on-line access to 
<a href="http://www.bowker.com/bop/">Books Out Of Print</a>...
for thirty bucks per week. Oh well.)
<p>

<h3><a name="convert">Converting UPC to ISBN</a></h3>

The bar-code on a book is a thirteen-digit number, starting with "978".
(Apparently, the first three digits of a UPC indicate the country of
origin. "978" is officially Bookland. Cool, eh? The UPC number for a book
is sometimes called the "Bookland EAN".)
<p>

An ISBN is a ten-digit number (the last digit may be "X").
<p>

A conversion must be found.
<p>

Fortunately, it's trivial. The
<a href="http://isbn.nu/">http://isbn.nu/</a>
search form actually does it in JavaScript:
<p>

<blockquote>
<pre>if (indexisbn.indexOf("978") == 0) {
   isbn = isbn.substr(3,9);
   var xsum = 0;
   var add = 0;
   var i = 0;
   for (i = 0; i &lt; 9; i++) {
        add = isbn.substr(i,1);
        xsum += (10 - i) * add;
   }
   xsum %= 11;
   xsum = 11 - xsum;
   if (xsum == 10) { xsum = "X"; }
   isbn += xsum;
}
</pre>
</blockquote>
<p>

Not that JavaScript isn't annoying and stupid, of course. (I keep it turned
off, so I can't even <em>use</em> the UPC search function on that web site.)
But it saved me from looking up the details of 
<a href="http://www.bisg.org/algorithms.html">UPC and ISBN checksums</a>.
<p>

(Small footnote: Chris Taylor contributes the 
<a href="eantoisbn-java.txt">Java code</a> equivalent to the 
Javascript above.)
<p>

<h4>The snag:</h4>

This was a doozy.
<p>

Did I say the bar-code was a thirteen-digit number, starting with 978?
I lied. <em>Some</em> books have that EAN code. Others have a
true UPC code, which is twelve digits. Other books have both
(the EAN is often inside the cover.)
<p>

Moreover, either kind of code can have a five-digit extension. On an
EAN, the extension gives the book's suggested retail price. On a UPC,
the second half of the <em>main</em> barcode gives the price, and the
extension gives half the ISBN, and the other half of the ISBN is...
<p>

Missing. I told you the snag was a doozy.
<p>

The first half of the main UPC barcode is a <em>publisher number</em>,
which <em>corresponds</em> to an ISBN prefix. You have to look it up in
a table. Combine the prefix with the five-digit extension, tack on the
checksum, and you have the full ISBN.
<p>

But you can't <em>get</em> such a table anywhere. I don't think Bowker sells
one -- they're in charge of ISBNs, not UPC publisher numbers.
<p>

How to deal? The obvious suggestion (which wasn't obvious to <em>me</em>
until Christopher Davis suggested it, thank you Christopher)
is to <em>use</em> those books that have both kinds of barcodes. When you scan,
scan both whenever possible. The clever scripts can then use that information
to build up a table of correspondences.
<p>

(Why does this silly EAN/UPC system exist? 
Basically, I'm told, because mass-market
books (mostly paperbacks) are sold in mass-market outlets, like grocery
stories and drugstores. Mass-market outlets often have ancient, creaky
old scanners which only understand UPC codes.)
<p>

(In the distant future -- 2005, specifically -- all scanners will be smart,
and publishers can start putting the EAN on every book, even mass-market
paperbacks. Of course, everyone's collection will still be full of books
without EANs. Life is hard.)
<p>

<h3><a name="scanner">Barcode Scanners</a></h3>

Back to Google. A search for
<a href="http://www.google.com/search?q=barcode+scanners&btnG=Google+Search">"barcode scanners"</a>
turned up several sources. The cheap one on the list -- well, a cheap one --
was
<a href="http://www.csensors.com/">Custom Sensors Inc.</a>
<p>

(Okay, I don't actually see CSI on the Google result list now. What the
hell, I got there somehow.)
<p>

CSI sells a couple of relevant toys. They have a pistol-grip point-and-zap
scanner
(<a href="http://www.csensors.com/ccdsheet.html">CCD-8000</a>),
and a smaller wand scanner
(<a href="http://www.csensors.com/mt205.html">MT-605</a>). 
These cost about a hundred bucks each, give or take, depending on model.
(They have more expensive models too, but I assume the typical book-scanner
has spent all his money on books.)
<p>

(I went for the wand, on the theory that simpler is better. Also, a bit
cheaper.)
<p>

One must mind the interfaces. Both of these products comes in several forms.
You can get them with an RS-232 connector, or a "keyboard wedge". The
latter is a clever interface that plugs into the keyboard port of a computer,
so that the barcodes you scan appear just as if you'd typed them on the
keyboard. The keyboard wedge means that you don't need any data-capture
software; just start up any text editor.
<p>

I actually wanted the thing to work on both my older Macintoshes, which
use ADB connectors, and my PowerBook, which has USB. CSI sells a separate
USB adaptor gizmo
(<a href="http://www.csensors.com/mt606.html">MT-606</a>). This converts
one of the keyboard wedge interfaces to a USB connection. Thirty bucks.
However, my older Macintoshes lose; the manufacturer no longer makes the
wand with a Mac ADB interface.
<p>

<h4>The snag:</h4>

None, other than obsolence of ADB. The order was easy; I called them,
named a model, paid by credit card, and it arrived within a week.
<p>

I did have to be careful to program the scanner correctly.
(How do you program a bar-code scanner? Right! You point it at a
special table of bar-codes! I love it.) I set it up to read EAN
and UPC, always including the first and last digit, and <em>optionally</em>
including the five-digit extension.
<p>

<h3><a name="query">Querying for Titles</a></h3>

Presume that I've got a simple text file, containing UPC numbers, one
per line. I need a program which will convert those to ISBNs, send them
to Amazon via HTTP, and parse Amazon's HTML response page.
<p>

This is a job for Perl!
<p>

Well, I don't know Perl. Perl is fuggly.
I've put off learning it this long; I have no
great desire to wade in now. Someone (a different someone :-) suggested 
<a href="http://www.python.org/">Python</a>. Python is simple.
The dumbass whitespace formatting is annoying, but not in a way that makes
the language harder to learn. Python it was.
<p>

(Footnote: It strikes me that one could modify the Python compiler to 
ignore whitespace, and use -- for example -- ":" by itself as a block
terminator. Since the compiler is part of the run-time environment, this
may even be trivial. It would make a lot of people happier with the
language, wouldn't it?)
<p>

I decided to split the task into its parts. The first script, 
<a href="shelvescripts/upcfind.py">upcfind.py</a>, 
goes over a list of scanned codes (both EAN and UPC) and updates
a master table called
<a href="shelvescripts/upc-map">upc-map</a>. 
This table, as described above, maps UPC prefixes to ISBN prefixes.
<p>

The second script,
<a href="shelvescripts/makeisbn.py">makeisbn.py</a>, 
reads the same list of scanned codes; it spits out a list
of ISBNs. (If it finds any ISBNs in the original list, it leaves them
alone. Any line that looks entirely confusing stays in the list, but
the script puts a "#" mark before it so that later programs can ignore
it.) This script uses the
<a href="shelvescripts/upc-map">upc-map</a>
table, of course. It's also smart enough to find instances where you
scanned both UPC and EAN barcodes of the same book, and only spit out
the ISBN once.
<p>

The third script, 
<a href="shelvescripts/shelve.py">shelve.py</a>, is the one that actually hits
the Internet. It reads the list of ISBNs, and writes two output lists.
The "out-err" file is a list of ISBNs that the databases
(Amazon and Chapters) didn't manage to find.
The "out-good" file has three lines for every ISBN successfully queried.
The three lines are ISBN, author, and title.
<p>

The fourth script,
<a href="shelvescripts/collate.py">collate.py</a>, 
is only relevant if you want to turn the data files into a
<a href="http://www.land-j.com/jfile.html">JFile</a>
database. (JFile is a shareware database app for the Palm.)
The collate.py script just takes one or more data files, strips out
blank lines and comments, sorts the data, and adds the one-line header
which you need to convert a text file to a JFile PDB.
(JFile comes with Windows tools to import data; I wrote
<a href="../jtrans.html">jtrans</a>,
which does the same job on Unix.)
<p>

The guts of these scripts are straightforward. Python has library
modules for reading lines of text, manipulating them, sending HTTP
queries, and returning the results. A bit of regexp cleverness was
needed to parse Amazon's HTML, but nothing painful.
<p>

(Of course, it's possible that Amazon will change its response page
format. They may even remove the ISBN query URL entirely.
I don't guarantee that these scripts will work. They worked for me, is
all.)
<p>

<h4>The snag:</h4>

I won't even try to go into it. These scripts went through several revisions
before I came up with this set of tools. They're still awkward, but I've
been able to use them. Honest.
<p>

<h3><a name="afterword">Afterword</a></h3>

Well, it's the end of a long weekend, and the database is in my Palm 3.
What do I conclude about the experience?
<p>

Different publishers hyphenate ISBNs in all <em>sorts</em> of
inconsistent ways. Ignore the punctuation, and look for ten digits.
(And don't trust the older "SBN" too far -- sometimes you can get a
valid ISBN by prepending a zero, but in general you can't.)
<p>

Scanning books is a lot of work. Do not imagine that this project consists
of a few minutes of beep-beep-beep, followed by four scripts and you're done.
I have six well-filled bookcases (figure 250 books each), and scanning in
all the books in a bookcase takes something like 45 minutes. Could be faster
if you're lucky, but if you have any quantity of old or obscure books, you'll
be typing a lot of comments by hand -- that eats time.
<p>

Then, after the scripts are run, you have to go back and fill in missing
titles, fix typoes and outright mistakes, and generally massage the data.
Make sure author's names and series titles are spelled consistently through
the data -- that sort of thing. That's another 45 minutes per bookshelf.
<p>

So, overall, I probably blew eight or nine hours on this project -- 
<em>not</em> counting the programming time. Was this worthwhile?
<p>

Hell yes. I could probably type in the titles and authors of 250 books
in less than ninety minutes... but it would be a two-person job: one to
read off books, one to type the data in. (Try to do both, and it's a running
battle whether you drop from exhaustion, turning from the computer to the
bookshelf and back, or just petrify your eyeballs from the focussing
strain.)
<p>

And the typing job would be awful and tedious, even by itself.
And you'd have that editing-proofing-massaging stage to do
<em>anyway</em>.
<p>

So this work certainly saved me folks-hours. It saved me effort; editing
a generated list for mistakes is much easier than generating the list yourself,
even if it takes nearly as much time. And, I shouldn't even need to say,
the prospect of doing the job geekly got me to <em>do</em> it -- I would
never have started if the only option had been dronely.
<p>

<h4><a name="afterafter">After afterword:</a></h4>

Skip the Penguin has sent in 
<a href="shelvescripts/htmlmake.sh">htmlmake.sh</a>,
a one-line shell script to mangle the output of collate.py into an
HTML page. I've added it to the script package.
<p>

8/28/00: Dan Poirier reports that the Amazon web searcher has to be
jiggered. In shelve.py, line 73, change 
<code>re.compile('/Author=([^/"]*)')</code>
to
<code>re.compile('&amp;field-author=([^/"]*)')</code>.
I haven't tried this myself.
<p>

8/29/00: Radio Shack is giving away free barcode scanners as part of
<a href="http://www.getcat.com/">some marketing program I don't understand</a>.
Skip the Penguin has put up a page about
<a href="http://www.plover.net/~skip/cc/">using the CueCat scanner
for your own purposes</a> (including cataloging books). Linux and
Windows instructions included.
Or see the
<a href="http://oss.lineo.com/projects.html">Lineo</a> page for
another Linux CueCat driver.
<p>

Further updates on
<a href="updates.html">this page</a>,
since appending them here in the middle doesn't make sense.

<hr>

<h3><a name="quick">Skip the History, Make it Work</a></h3>

Actually, if you skipped the sections above, you're going to get
confused. But I'll try to hit the highlights.
<p>

<ol>
<li>Buy a bar-code scanner.

<ul>
<li>I got a
<a href="http://www.csensors.com/">Custom Sensors Inc.</a>
<a href="http://www.csensors.com/mt205.html">MT-605</a>. 
<li>The
<a href="http://www.csensors.com/ccdsheet.html">CCD-8000</a>
may also work.
<li>If your machine uses a PS/2 keyboard, ask for that model of
keyboard wedge. If your machine uses USB devices, get the
<a href="http://www.csensors.com/mt606.html">MT-606</a> adaptor also.
<li>Radio Shack is giving away free CueCat scanners; see the
<a href="#afterafter">After Afterword</a> 
section for links on making that work.
</ul>

<li>Program the scanner.

<ul>
<li>Use the following options:
<ul>
<li>Accept UPC-A and EAN-13.
<ul>
<li>I turned off the ability to accept most other barcodes, to reduce
the possibility of confusion, but I don't think this is really necessary.
</ul>
<li>For both UPC-A and EAN-13, send both first digit and last (check) digit.
<li>If you have an option to convert EAN-13 to ISBN, turn it off. 
(The makeisbn.py script handles this.)
<li>Accept five-digit supplement codes. (Again, I turned off two-digit
supplement codes, but this probably isn't necessary.)
<li>Set recognition of supplement codes to be <em>optional</em>
("transmit if present"), not mandatory ("must be present"). This is
important, because not all barcodes have the extension, and they're not
necessary for EAN codes.
<li>Put a space between the main barcode and the five-digit supplement.
</ul>
<li>Now test the scanner. A recent mass-market paperback should have both
UPC and EAN barcodes (back cover and inside front cover.)
<ul>
<li>The UPC code should come out with the format "012345678900 12345" -- 
twelve digits, a space, five digits.
<li>The EAN code should code out with the format "9780123456789 12345" --
thirteen digits (beginning with 978), a space, five digits.
</ul>
</ul>

<li>Grab the 
<a href="shelvescripts.tar.Z">Python scripts</a>.

<ul>
<li>This tar file contains all four scripts, plus the upc-map file.
You should download the tar file, rather than trying to download the four
scripts individually, because Python's dumb whitespace formatting is
susceptible to breakage.
</ul>

<li>Scan a lot of books. 

<ul>
<li>One bookshelf at a time worked best for me.
<li>Scan straight into your favorite text editor.
<li>The EAN (978-) barcode is more reliable than the UPC barcode.
<li>But it's best to scan both, where both are available.
<ul>
<li>Especially if you have books from many publishers.
<li>Generally, only paperbacks will have both barcodes -- not all paperbacks
either, just some.
<li>Scan the codes consecutively. The scripts will
get confused if the two barcodes for the same book are several lines apart.
<li>It doesn't matter which code you scan first.
</ul>
<li>Make sure you get the five-digit extension on all UPC barcodes.
(The extension doesn't matter for EAN codes.)
<li>If you can't get a good scan, or if a book just doesn't have barcodes,
you can type the ISBN into the scan file yourself. 
Ten digits, no spaces or hyphens.
<li>You can also put a comment on any line. 
<ul>
<li>Type a hash sign (#) after
any scanned number; you can put any text after the hash sign.
<li>The comment will be preserved by the scripts you run later. 
That's why it's handy; you can remind yourself what book that line
represents, in case the Internet lookup fails.
</ul>
<li>If a book has no ISBN at all, use a comment on a line by itself.
<ul>
<li>Just enter a line that starts with a hash sign. Any text can follow
the hash sign.
<li>Later, after all the Internet lookup is finished, you can use the
comment to add the book manually to your database.
</ul>
<li>You can also add a line of the form <code>XXXXXX=YYYY</code>
(no spaces or other characters). This indicates that the six-digit
UPC prefix <code>XXXXXX</code> maps to the ISBN prefix <code>YYYY</code>.
<ul>
<li>You generally won't need to add lines like this -- upc-map comes with
common values already in place, and upcfind.py can deduce more from
double-scanned books.
<li>But if makeisbn.py complains (see below), you may want to find the
book in question and enter the data manually, using this sort of line.
</ul>
</ul>

<li>Run upcfind.py on your scanned list (to deduce UPC prefix mappings).

<ul>
<li><code>upcfind.py scanfilename</code>
<li>Make sure the upc-map file is in the current directory, so upcfind.py
can read and update it.
<li>The program will warn you of potential problems.
<ul>
<li>The most likely problem is: <code>line <em>L</em>: UPC prefix <em>X</em> is already in the list as <em>Y</em> -- not <em>Z</em></code>
<li>There's not much you can do about this. In some cases, you just can't
reliably get the ISBN from the UPC.
<li>If possible, figure out which book is referred to, and get an EAN scan
from every book from the same publisher / series / whatever.
<li>If not, at least try to add comments, so that you can type in the
title and author manually later on.
</ul>
</ul>

<li>Run makeisbn.py on your scanned list (to turn the barcodes into ISBNs).

<ul>
<li><code>makeisbn.py scanfilename &gt; isbnfilename</code>
<li>Again, make sure the upc-map file is in the current directory.
<li>The output file will contain warnings of any problems.
<ul>
<li><code>UPC barcode requires five-digit extension</code> -- indicates
that you scanned a UPC code without the extension.
<ul>
<li>You'll have to
re-scan it, or add the digits to that line by hand, or add a comment
indicating what book it is.
</ul>
<li><code>Unrecognized format</code> -- indicates that the line doesn't
seem to be either a UPC, EAN, or ISBN.
<li><code>Unknown UPC prefix <em>X</em></code> -- indicates that the
prefix wasn't found in the upc-map table.
<ul>
<li>You should add a comment.
<li>If the book has both barcodes, you could also rescan the book, getting
both codes. This would register the prefix in upc-map, thus solving
the problem for <em>every</em> book from that publisher.
<li>You could also add an <code>XXXXXX=YYYY</code> line to your file.
See above.
</ul>
</ul>
</ul>

<li>Go back to your bookshelf, look over the output of makeisbn.py,
and fill in any comments, barcodes, or <code>XXXXXX=YYYY</code> lines
that are necessary.

<ul>
<li>If you've added anything to your scan file, you
should re-run upcfind.py, to re-update upc-map. Then re-run makeisbn.py,
to make a more complete ISBN list.
<li>Rinse and repeat, until there are no more errors.
</ul>

<li>Run shelve.py on the ISBN list 
(which actually looks up the titles and authors).

<ul>
<li><code>shelve.py isbnfilename &gt; datafilename</code>
<li>This will take a while; at least a couple of seconds per book, even
on a fast Net connection.
<li>The output is a list of <em>tab-separated</em> lines -- author's name,
followed by a single tab character, followed by the title. 
<li>Comment lines start with a hash sign (#), and have no tab.
<li>The queries are summarized on the screen, in addition to being stored
in datafilename. (More precisely, the progress is sent to standard error,
and the final results are sent to standard output.)
</ul>

<li>Go back to your bookshelf yet again, and go over the data file.

<ul>
<li>Replace all the comment lines with actual titles and authors.
Be careful to use a single tab per line.
<li>Also, you probably want to edit the data that's already there.
The Web databases often have typos, and the author lists include
names you may want to delete -- illustrators' names, and astoundingly
bad alternate spellings of the real author.
</ul>

<li>Go through the entire process again, with the next bookshelf.

<ul>
<li>After the first bookshelf, I had most of the UPC mappings I needed.
So on subsequent shelves, I didn't double-scan -- I only scanned the EAN code.
For the common publishers, anyway.
</ul>

<li>Now you have a bunch of data files. Import them into whatever database
you plan to keep them in.

<li>If you want to transfer the data to a
<a href="http://www.land-j.com/jfile.html">JFile</a>
database on a PalmOS PDA, do the following:

<ol>

<li>Run collate.py on all the data files you've created.

<ul>
<li><code>collate.py datafilename1 datafilename2 datafilename3 &gt; dbfile</code>
<li>This simply concatenates the files, strips out any remaining comments, 
sorts the entries, and adds an "Author / Title" header line.
</ul>

<li>Run 
<a href="../jtrans.html">jtrans</a>
to convert dbfile to a PalmOS PDB file.

<ul>
<li><code>jtrans -e -o -n Books dbfile dbfile.pdb</code>
<li>If you have JFile Pro, leave out the "-o" flag.
</ul>

<li>Use your regular Palm tools to upload dbfile.pdb to your Palm.

</ol>

<li>If you want to transform the data to an HTML page, do the following:

<ol>
<li>Run collate.py and htmlmake.sh on all the data files you've created.
<ul>
<li><code>collate.py datafilename1 datafilename2 datafilename3 | htmlmake.sh &gt; books.html</code>
</ul>
</ol>

<li>Check my
<a href="updates.html">Book-Scanning Updates Page</a>
to see if there are any important details I left out of this
document.

</ol>

<hr>
Last updated October 2, 2000.
<p>

<em><a href="booklist.html">The Book List</a></em>
<br>
<em><a href="updates.html">Recent Updates to This Document</a></em>
<p>

<em><a href="../home.html">Zarfhome</a></em>
<em><a href="../sitemap.html#bookscan">(map)</a></em>
<em><a href="../cave/bookscan.html">(down)</a></em>

</body>
</html>
