#!/usr/bin/python

# IN PROGRESS
# export PYTHONPATH=`pwd`/../lib

# Messages:
# UI-LOGGEDIN | user | balance | ttl | anonymous [01]
# - Go to the login screen
# UI-PASSWORD | user | balance | hash | tries | ttl
# - Go to the password query screen
# UI-BOUGHT   | item | price | balance | ttl
# - Notify the user of a purchase
# UI-TTL      | ttl
# - Reset the TTL
# UI-BALANCE balance
# - Set the balance
# UI-LOGGEDOUT
# - Return to Login-Idle Screen
# UI-NOTICE | notice | color
# - Issue a notice to a logged in user
# + I don't think I am using this...
# UI-FP-NOTICE | count | message | complete [01]


from wxPython.wx import *
import sys
from pybob import servio
import threading
import wx.lib.newevent
import crypt

#from pybob.pysodaui.keyboard import SodaKeyBoard
from pybob.pysodaui.config import *

#from pybob.pysodaui.sodabutton import *
#from pybob.pysodaui.sodapanel import *
from pybob.pysodaui.sodaLoginIdlePanel import *
from pybob.pysodaui.sodaLoginPanel import *
from pybob.pysodaui.sodaPasswordPanel import *
from pybob.pysodaui.sodaPurchasePanel import *
from pybob.pysodaui.sodaFpPanel import *

from pybob.pysodaui.stats import *



STATE_LOGIN_IDLE = 1
STATE_LOGIN      = 2
STATE_PASSWORD   = 3
STATE_PURCHASE   = 4
STATE_FPLEARN    = 5

LogoutEvent, EVT_LOGOUT_EVENT = wx.lib.newevent.NewEvent()
LoginEvent, EVT_LOGIN_EVENT = wx.lib.newevent.NewEvent()
PasswordEvent, EVT_PASSWORD_EVENT = wx.lib.newevent.NewEvent()
BoughtEvent, EVT_BOUGHT_EVENT = wx.lib.newevent.NewEvent()
TtlEvent, EVT_TTL_EVENT = wx.lib.newevent.NewEvent()
BalanceEvent, EVT_BALANCE_EVENT = wx.lib.newevent.NewEvent()
FpEvent, EVT_FP_EVENT = wx.lib.newevent.NewEvent()

# Deprecated
def urldecode(url):
    "Return a dict of the variables encoded in a GET request"
    vars = url[url.find("?")+1:]

    values = {}

    for keyval in vars.split("&"):
        (key, value) = keyval.split("=")
        values[key] = value

    print values

    return values





class SodaFrame(wxFrame):
    '''The Main Window of the soda UI

    The GUI section is implemented as a series of panels that are
    constructed via the make*() functions.  They are hidden/revealed by
    the begin*/end* functions that are in turn invoked by the
    changeState function.

    Changes in state can be triggered by interactions with the servio
    interface, or via the buttons contained within the panels.  The
    servio interface callbacks are the handle* functions.  The button
    callbacks are on* and the event callbacks (generated by the button
    handlers and the handle*) are on*Event.  We can change naming
    schemes later if we feel so inclined.

    We currently have the following states:

    Login Idle - In the old version, this shows stats of soda purchases.
                 For us, it could show other things, perhaps rotating 
                 occasionally.
    Login - Interaction with the screen keyboard to login and password,
            etc.

    Purchase - This is essentially the logged-in screen.  I didn't want
               all of the states to be log*.  This state runs a timer
               that counts to zero.  This replaces tha javascript update
               hack of the old system.  It currently tries to trigger a
               logout at the end, but the backend currently executes a
               logout, so this doesn't really need to happen.

    The ServIO callback handlers are executed from a separate thread,
    so you need to be careful when calling thread-unsafe gui functions.
    Most of the interactions I have programmed come through
    wx.PostEvent, which is threadsafe.
    '''

    state = STATE_LOGIN_IDLE

    backgroundColour = 'BLACK'
    foregroundColour = 'WHITE'

    passwordLimit = 3


    def __init__(self, parent, ID, title, bus):
        '''
        Initializes the Frame with the title, builds the panels, and
        starts the system in the LoginIdle State
        '''
        wxFrame.__init__(self, parent, ID, title,
                         wxDefaultPosition, wxSize(800, 600))

        self.SetBackgroundColour(self.backgroundColour)
        self.SetForegroundColour(self.foregroundColour)

        self.font = wxFont(30, 
                      wxFONTFAMILY_DEFAULT,
                      wxFONTSTYLE_NORMAL,
                      wxFONTWEIGHT_NORMAL,
                      False,
                      "lcars"
                      )

        self.bus = bus

        self.SetFont(self.font)

        self.makeLoginIdlePanel()
        self.makeLoginPanel()
        self.makePasswordPanel()
        self.makePurchasePanel()
        self.makeFpPanel()

        self.Bind(EVT_LOGIN_EVENT, self.onLoginEvent)
        self.Bind(EVT_PASSWORD_EVENT, self.onPasswordEvent)
        self.Bind(EVT_LOGOUT_EVENT, self.onLogoutEvent)
        self.Bind(EVT_BOUGHT_EVENT, self.onBoughtEvent)
        self.Bind(EVT_TTL_EVENT, self.onTtlEvent)
        self.Bind(EVT_BALANCE_EVENT, self.onBalanceEvent)
        self.Bind(EVT_FP_EVENT, self.onFpEvent)

        self.TTLTimer = wxTimer(self, 0)
        self.Bind(EVT_TIMER, self.onTTLTimerFire)

        self.TTLTimer.Stop()


        self.FPServVL = self.bus.getVarList("FPSERV")

        self.debugging = False

        self.wall_of_shame = []
        self.wall_of_shame_cv = threading.Condition()


    def debug(self, string):
        if self.debugging:
            print string

    def changeState(self, new_state):
        '''
        Close down the old state and enter new_state, if it
        differs.
        '''

        if self.state == new_state:
            self.debug("Not transitioning -- same state" + str(self.state))
            return

        if self.state == STATE_LOGIN_IDLE:
            self.endLoginIdle()
        elif self.state == STATE_LOGIN:
            self.endLogin()
        elif self.state == STATE_PASSWORD:
            self.endPassword()
        elif self.state == STATE_PURCHASE:
            self.endPurchase()
        elif self.state == STATE_FPLEARN:
            self.endFpLearn()
        else:
            print "Unknown Old State"

        # LoginIdle may remain broken, but the rest should work after.
        self.state = new_state

        if new_state == STATE_LOGIN_IDLE:
            self.debug("State: Idle Screen")
            self.beginLoginIdle()
        elif new_state == STATE_LOGIN:
            self.debug("State: Login")
            self.beginLogin()
        elif new_state == STATE_PASSWORD:
            self.debug("State: Password")
            self.beginPassword()
        elif new_state == STATE_PURCHASE:
            self.debug("State: Purchase Screen")
            self.beginPurchase()
        elif new_state == STATE_FPLEARN:
            self.debug("State: FPLearn")
            self.beginFpLearn()
        else:
            self.debug("Unknown State")


    #
    # Functions associated with the LoginIdle State
    #
    def makeLoginIdlePanel(self):
        self.idlePanel = SodaLoginIdlePanel(self, 
                                            -1, 
                                            wxPoint(0,0), 
                                            self.GetSize())

        self.Bind(EVT_BUTTON, self.onLogin, id=ID_LOGIN)

        self.idlePanel.Layout()
        self.idlePanel.Show(false)

    def beginLoginIdle(self):
        self.debug("Begin Login Idle")
        self.idlePanel.MakeSodaStatsPanel()
        self.idlePanel.Show(true)
        self.bus.sendDebug("beginLoginIdle")

    def endLoginIdle(self):
        self.idlePanel.Show(false);
        self.bus.sendDebug("endLoginIdle")

    def onLogin(self, event):
        self.changeState(STATE_LOGIN)

    # 
    # Functions associated with the Login State
    #
    def makeLoginPanel(self):
        self.loginPanel = SodaLoginPanel(self, -1, wxPoint(0,0), self.GetSize())

        self.Bind(EVT_BUTTON, self.onDoLogin, id=ID_DOLOGIN)
        self.Bind(EVT_BUTTON, self.onLoginCancel, id=ID_CANCEL)

        self.loginPanel.Layout()
        self.loginPanel.Show(false)

    def beginLogin(self):
        self.loginPanel.Show(true)
        self.bus.sendDebug("beginLogin")

    def endLogin(self):
        self.loginPanel.Clear()
        self.loginPanel.Show(false)
        self.bus.sendDebug("endLogin")

    def onDoLogin(self, event):
        login = self.loginPanel.GetLogin()

        # If it fails, we'll stay here
        self.loginPanel.Clear()

        if len(login) > 0:
            self.querytag = servio.genTag()
            self.bus.send(["LOGIN",
                           login])

    def onLoginCancel(self, event):
        # Inputs are cleared by the end* functions.
        self.changeState(STATE_LOGIN_IDLE)

    def onLoginEvent(self, event):
        self.bus.sendDebug("Login Event")

        self.user = event.user
        self.balance = event.balance
        self.timeout = int(event.timeout)
        self.anonymous = int(event.anonymous)
        self.changeState(STATE_PURCHASE)

    def onPasswordEvent(self, event):
        self.bus.sendDebug("Password Event")
        self.user = event.user
        self.balance = event.balance
        self.timeout = int(event.ttl)
        self.hash = event.hash
        self.changeState(STATE_PASSWORD)

    # 
    # Functions associated with the Password State
    #
    def makePasswordPanel(self):
        self.passwordPanel = SodaPasswordPanel(self, 
                                               -1, 
                                               wxPoint(0,0), 
                                               self.GetSize())

        self.Bind(EVT_BUTTON, self.onDoPassword, id=ID_DOPASSWORD)

        self.passwordPanel.Layout()
        self.passwordPanel.Show(false)

    def beginPassword(self):
        self.passwordPanel.SetStatusText('Authenticating ' + self.user, 'YELLOW')
        self.passwordPanel.Show(true)
        self.passwordCount = self.passwordLimit
        self.bus.sendDebug("beginPassword")

    def endPassword(self):
        self.passwordPanel.Clear()
        self.passwordPanel.Show(false)
        self.bus.sendDebug("endPassword")

    def onDoPassword(self, event):
        password = self.passwordPanel.GetPassword()
        self.passwordPanel.Clear()

        if self.hash is not None:
            if crypt.crypt(password, self.hash) == self.hash:
                self.bus.send(["LOGIN", self.user, self.balance])
                return

        self.passwordCount = self.passwordCount - 1

        if self.passwordCount == 0:
            self.bus.send(["LOGIN-DENIED", self.user])
            self.changeState(STATE_LOGIN_IDLE)

    #
    # Functions associated with the Purchase State
    #
    def makePurchasePanel(self):
        self.purchasePanel = SodaPurchasePanel(self, 
                                               -1, 
                                               wxPoint(0,0), 
                                               self.GetSize())

        self.purchasePanel.Bind(EVT_BUTTON, self.onLogout, id=ID_LOGOUT)
        self.purchasePanel.Bind(EVT_BUTTON, self.onFpLearn, id=ID_FPLEARN)

        self.purchasePanel.Layout()
        self.purchasePanel.Show(false)


    def beginPurchase(self):
        self.purchasePanel.SetStatusText('Ready for ' + self.user, 'GREEN')
        self.purchasePanel.SetUser(self.user)
        self.purchasePanel.SetBalance(self.balance)
        # These vars should be setup by the onLoginEvent
        self.updateTTLTimerLabel(STATE_PURCHASE)

        # Kick off the timer.
        self.TTLTimer.Start(1000)

        self.purchasePanel.Show(true)
        self.bus.sendDebug("beginPurchase")

    def endPurchase(self):
        self.purchasePanel.Clear()
        self.TTLTimer.Stop()
        self.purchasePanel.Show(false)
        self.bus.sendDebug("endPurchase")

    def onFpLearn(self, event):
        # Refuse fp learning to anonymous users.
        if self.anonymous:
            self.purchasePanel.SetStatusText('Refusing FPLearn to '
                                                + self.user, 'RED')
            return

        self.changeState(STATE_FPLEARN)

    def onLogout(self, event):
        self.bus.send(["LOGOUT"])

    def onLogoutEvent(self, event):
        self.changeState(STATE_LOGIN_IDLE)

    def onBoughtEvent(self, event):
        self.balance = event.balance
        self.timeout = int(event.ttl)

        self.purchasePanel.SetBalance(self.balance)
        self.purchasePanel.AddLog(event.item + " for " + monetize(event.price))

        self.bus.sendDebug("Bought Event: " + event.item)

    def onTtlEvent(self, event):
        self.timeout = int(event.ttl)
        self.updateTTLTimerLabel(self.state)
        self.bus.sendDebug("Ttl Event")

    def onBalanceEvent(self, event):
        self.balance = int(event.balance)
        self.purchasePanel.SetBalance(self.balance)
        self.bus.sendDebug("Balance Event")

    #
    # FP Panel
    #
    def makeFpPanel(self):
        self.fpPanel = SodaFPPanel(self,
                                   -1,
                                   wxPoint(0,0),
                                   self.GetSize())

        self.fpPanel.Bind(EVT_BUTTON, self.onFpCancel, id=ID_CANCEL)

        self.fpPanel.Layout()
        self.fpPanel.Show(false)

    def onFpCancel(self, event):
        self.changeState(STATE_PURCHASE)

    def beginFpLearn(self):
        self.bus.sendDebug("beginFpLearn")
        self.fpPanel.SetStatusText('Learning FP for ' + self.user, 'BLUE')
        self.fpPanel.Show(True)
        self.TTLTimer.Start(1000)
        self.updateTTLTimerLabel(STATE_FPLEARN)
        self.bus.send(["LEARNSTART"])

    def endFpLearn(self):
        self.bus.sendDebug("endFpLearn")
        self.fpPanel.Show(False)
        self.fpPanel.Clear()
        self.TTLTimer.Stop()
        self.bus.send(["LEARNEND"])


    def onFpEvent(self, event):
        # XXX
        #if self.state != STATE_FPLEARN:
        #    self.changeState(STATE_FPLEARN)

        self.fpPanel.SetCount(event.count)
        self.fpPanel.SetMessage(event.msg)

        if event.complete == "1":
            self.changeState(STATE_PURCHASE)

    def queryWallOfShame(self):
        self.bus.send(["BOBDB-QUERYWALLOFSHAME"])

    def getWallOfShame(self):
        self.wall_of_shame_cv.acquire()
        self.queryWallOfShame()
        self.wall_of_shame_cv.wait(5)
        self.wall_of_shame_cv.release()
        return self.wall_of_shame

    # gUI helper
    def updateTTLTimerLabel(self, state):
        if state == STATE_PURCHASE:
            self.purchasePanel.SetTTL(str(self.timeout))
        elif state == STATE_FPLEARN:
            self.fpPanel.SetTTL(str(self.timeout))
        else:
            self.bus.sendDebug("mysterious timer event")

    def onTTLTimerFire(self, event):
        self.timeout = max(self.timeout - 1, 0)
        #if self.timeout <=  0:
        #    evt = LogoutEvent()
        #    wx.PostEvent(self, evt)

        self.updateTTLTimerLabel(self.state)




    #
    # ServIO callback handlers.
    #

    def handleUiOpen(self, data):
        values = urldecode(data[1])

        if 'msg' in values:
            self.handleIndexPhp(values['msg'], values)
        elif 'message' in values:
            self.handleIndexPhp(values['message'], values)
        else:
            self.bus.sendDebug("msg not present in UI-OPEN")
            return

    def handleSysSet(self, data):
        if data[1] == "MOZ-KIOSK":
            if data[2] == "real_location":
                self.handleUiOpen(["UI-OPEN",data[4]])

    def handleUiLoggedIn(self, data):
        self.debug("UI-Logged in message received")
        evt = LoginEvent(user=data[1],
                balance=data[2],
                timeout=data[3],
                anonymous=data[4])
        wx.PostEvent(self, evt)

    def handleUiLoggedOut(self, data):
        self.debug("UI-Logged out message received")
        evt = LogoutEvent()
        wx.PostEvent(self, evt)

    def handleUiPassword(self, data):
        evt = PasswordEvent(user=data[1],
                            balance=data[2],
                            hash=data[3],
                            ttl=data[4])
        wx.PostEvent(self, evt)

    def handleUiBought(self,data):
        evt = BoughtEvent(item=data[1],
                price=data[2],
                balance=data[3],
                ttl=data[4])
        wx.PostEvent(self, evt)

    def handleUiBalance(self,data):
        evt = BalanceEvent(balance=data[1])
        wx.PostEvent(self, evt)

    def handleUiTtl(self,data):
        evt = TtlEvent(ttl=data[1])
        wx.PostEvent(self, evt)

    def handleUiFpNotice(self, data):
        evt = FpEvent(count=data[1],
                      msg=data[2],
                      complete=data[3])
        wx.PostEvent(self, evt)

    def handleWallOfShame(self, data):
        self.wall_of_shame_cv.acquire()

        wall = []
        for i in xrange(0,len(data[1:]),2):
            wall.append({'username':data[i+1], 'balance':float(data[i+2])})
        self.wall_of_shame = wall

        self.wall_of_shame_cv.notifyAll()
        self.wall_of_shame_cv.release()


class SodaApp(wxApp):
    def OnInit(self, unique=True):
        if unique:
            self.bus = servio.ServIO("PYUI", "1.0", "0:u")
        else:
            self.bus = servio.ServIO("PYUI", "1.0", 100)

        self.bus.defaultHandler(servio.noop_handler)

        frame = SodaFrame(NULL, -1, "Python Soda UI", self.bus)

        #self.bus.watchMessage("UI-OPEN", frame.handleUiOpen)
        #self.bus.watchMessage("MOZ-OPEN", frame.handleUiOpen)
        #self.bus.watchMessage("SYS-SET", frame.handleSysSet)

        self.bus.watchMessage("UI-LOGGEDIN", frame.handleUiLoggedIn)
        self.bus.watchMessage("UI-LOGGEDOUT", frame.handleUiLoggedOut)
        self.bus.watchMessage("UI-PASSWORD", frame.handleUiPassword)
        self.bus.watchMessage("UI-BOUGHT", frame.handleUiBought)
        self.bus.watchMessage("UI-BALANCE", frame.handleUiBalance)
        self.bus.watchMessage("UI-TTL", frame.handleUiTtl)
        self.bus.watchMessage("UI-FP-NOTICE", frame.handleUiFpNotice)
        self.bus.watchMessage("BOBDB-WALLOFSHAME", frame.handleWallOfShame)

        self.bus_thread = threading.Thread(target=self.bus.receive)
        self.bus_thread.start()

        # This is the only way I could think to do this.
        self.bus_check_timer = wxTimer(self, 0)
        self.Bind(EVT_TIMER, self.onBusCheckTimerFire)
        # Run once a second.
        self.bus_check_timer.Start(1000)

        frame.Show(true)
        self.SetTopWindow(frame)

        frame.beginLoginIdle()

        return true

    def onBusCheckTimerFire(self, event):
        if not self.bus_thread.isAlive():
            print "Servio Thread Disappeared... Exiting."
            sys.exit(1)

    def Exit(self):
        self.bus.exit()

app = SodaApp(0)
app.MainLoop()
app.Exit()
